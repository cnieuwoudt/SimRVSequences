---
title: "SimRVSequences"
author: "Christina Nieuwoudt and Jinko Graham"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
setspace: doublespacing
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body{ /* Normal  */
   font-size: 12px;
}
</style>

<style>
    p {line-height: 3em;}
</style>

# Table of contents
1. [Introduction](#introduction)
2. [`SimRVSequences` Assumptions](#Assumptions)
3. [Exon-Only Data with SLiM 2.0](#SlimMat)
4. [Import SLiM 2.0 Data](#SlimDat)
5. [Select Pool of Causal Variants](#CausalVars)
6. [Pedigree Data](#PedSample)
7. [Simulate Sequence Data](#SimSeq)
8. [References](#Ref)


# 1. Introduction <a name="introduction"></a>

Family-based studies are more attractive than case-control studies because they have more power to detect causal rare variants, require smaller sample sizes, and can more accurately detect sequencing errors (cite Wiseman?).  However, data collection for these studies is both time consuming and expensive.  

`SimRVSequences` provides methods to simulate sequence data for family-based studies.  To accomplish this we require: (1) single-nucleotide variant (SNV) data from a sample of unrelated individuals and (2) a sample of ascertained pedigrees.  Presently, we streamline this process for pedigrees simulated by `SimRVPedigree` and exon-only SNV data produced by SLiM 2.0 [1].  In this vignette we illustrate how the methods provided by `SimRVSequences` may be used to accomplish this task.

# 2. `SimRVSequences` Assumptions <a name="Assumptions"></a>

1. Given a sample of ascertained pedigrees we allow for the possibility that different families may segregate different rare variants, but make the assumption that within a family genetic cases are due to a causal rare variant (cRV) that increases disease susceptibility.  That is, each pedigree may have no more than 1 cRV segregating among descendents.  Furthermore, only 1 copy of the familal cRV may be introduced to the pedigree.

2. We use a preferential gene-drop algorithm to ensure that the cRV is inherited by the correct descendents.
  1. Sample founder haplotypes conditional on cRV status at the familial disease locus:
  2. For each parent-offspring pair:
     1. Simualte recombination amand formation of gametes. We assume that genetic recombination can be modelled by a gamma distribution with shape = 2.63, rate = 2*2.63 (cite Voorrips).  (NOTE: users can simulate recombination according to Haldane's model if they set shape = 1 and rate = 0.5, check parameter setting before JINKO.)
     2. Sample the gamete inherited by the offspring conditional on the offspring's cRV status.


# 3. Exon-Only Data with SLiM 2.0 <a name="SlimMap"></a>

SLiM 2.0 allows users to specify a recombination map to simulate recombination hot spots.  Additionally, the recombination map can be used to simulate mutations over unlinked regions (i.e. in different chromosomes) or in linked but non-contiguous regions (i.e in exon-only data).  The `create_slimMap` function may be used to create a recombination map to simulate exon-only data with SLiM.  We will illustrate this process using the `hg_exons` data set.

```{r}
# load the SimRVSequences library
library(SimRVSequences)

# load the hg_exons dataset
data("hg_exons")

# print the first four rows of hg_exons
head(hg_exons, n = 4)
```

As seen in the output above, the `hg_exons` data set catalogs the position of each exon in the 22 human autosomes. The data contained in `hg_exons` was collected from the UCSC Genome Browser (cite Genome and Table Browser). The variable `chrom` is the chromosome on which the exon resides, `exonStart` is the position of the first base pair in the exon, and `exonEnd` is the position of the last base pair in the exon.  The variable `NCBIref` is the NCBI reference sequence accession numbers for the coding region in which the exon resides.  In `hg_exons` overlapping exons are combined into a single observation; when exons from different genes have been combined the variable `NCBIref` will contain a multiple NCBI reference sequence accession numbers, separated by a comma.  We note that different NCBI reference sequence accession numbers may exist for isoforms or transcript variants of the same gene.  

The `create_slimMap` function has three arguments:

1. `exon_df`: A data frame that contains the positions of each exon to simulate.  This data frame must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `exon_df` does not contain any overlapping segments.  Prior to supplying exon data to `create_slimMap` users must combine overlapping exons into a single observation.  The `combine_exons` function may be used to accomplish this task.*  The variable `NCBIref`, as seen in `hg_exons`, is not required.
2. `mutation_rate`: the per site per generation mutation rate. By default, `mutation_rate= 1E-8`, as in Haris (2016).
3. `recomb_rate`: the per site per generation recombination rate.  By default, `recomb_rate= 1E-8`, as in Haris (2016).   
 
```{r}
# create recombination map for exon-only data using the hg_exons dataset 
s_map <- create_slimMap(exon_df = hg_exons)

# print first four rows of s_map 
head(s_map, n = 4)
```


The `create_slimMap` function returns a data frame with several variables:

1. `chrom`:  the chomosome number.
2. `seLength`: the length of the segment in base pairs.  *We assume that segments contain the postions listed in `exonStart` and `exonEnd.`  Therefore, for an exon, `segLength` is calculated as `exonEnd - exonStart + 1.`
3. `recRate`: the per site per generation recombination rate.  Following Harris (2016), segments between exons on the same chromosome are simulated as a single base pair with `rec_rate` = recombination rate * number of base pairs in the segment.  For each chromosome, a single site is created between the last exon on the previous chromosome and the first exon of the current chromosome.  This site will have recombination rate 0.5 to accommodate unlinked chromosomes.
4. `mutRate`: the per site per generation mutation rate.  Since we are interested in exon-only data, the mutation rate outside exons is set to zero.
5. `exon`: logical variable, `TRUE` if segment is an exon and `FALSE` if not an exon. 
6. `simDist`: the simulated distance, in base pairs. When `exon = TRUE`, `simDist = segLength`. For exons sim
7. `endPos`: The cumulative length of all segments.


The first row in the output above contains information about the genetic segment **before the first exon** on chromosome 1.  From `segLength` we can see that there are 11,872 base pairs before the first exon on chromosome 1, which is simulated as a single site since `simDist` = 1. The recombination rate for this segment is set to zero.  However, the first non-exon segement for any other chromosome will be 0.5 so that chromosomes are unlinked.  The mutation rate for this non-exon segment is set to zero since we are interested in exon-only data.   

The second row of the output catalogs information for the first exon on chromosome 1.  This exon contains 355 base pairs, hence `simDist` for this segment is 355.  The per site per genertation mutation and recombination rates for this exon are 1E-08.

The third row contains the information for the second non-exon segment on chromosome 1. This segment contains 384 base pairs. Notice again that we simulate this segment as a single site, but set the recombination rate to 384*1E-8 = 3.84E-6.


Only three of the variables returned by `create_slimMap` are required by SLiM 2.0 to simulate exon-only data: `recRate`, `mutRate`, and `endPos`.  The other variables seen in the output above are used by the `read_slim` function to remap mutations to their correct positions after simulation (see section 3 for details). 


SLiM 2.0 is written in a scripting language called Eidos. Unlike an `R` array, the first position in an Eidos array is 0.  Therefore, we must shift the variable `endPos` forward 1 unit before supplying this data to SLiM 2.0.

```{r}
# restrict output to the variables required by SLiM
slimMap <- s_map[, c(3, 4, 7)]

# shift endPos up by one unit
slimMap$endPos <- slimMap$endPos - 1

# print first four rows of slimMap 
head(slimMap)
```

We used SLiM 2.0 to generate neutral mutations in exons and allowed them to accumulate over 44,000 generations, as in Harris (2016).  However, SLiM is incredibly versatile and can accommodate many different types of simulations.  The creators of SLiM provide excellent resources and documentation to simulate forwards-in-time evolutionary data, which can be found at the SLiM website: https://messerlab.org/slim/ .

# 4. Import SLiM 2.0 Data <a name="SlimDat"></a>

To import data simulated by SLiM, we provide the `read_slim` function.  Presently, The `read_slim` function is only appropriate for data produced by SLiM's outputFull() method. We do not support output in MS or VCF data format (i.e. produced by outputVCFsample() or outputMSSample() in SLiM 2.0).


NOTE, we only allow for 0/1 mutations (figure out how to phrase this...)

The `read_slim` function has three arguments:

1. `file_path`: The file path of the .txt output file created by outputFull() in SLiM 2.0.
2. `keep_maf`: The largest allele frequency for retained SNVs. All variants with allele frequency greater than `keep_maf` will be removed. Please note, removing common variants is recommended for large data sets due to the limitations of data allocation in R.
3. `recomb_map`: A recombination map of the same format as the data frame returned by `create_slimMap`.  Users who followed the instructions in Section 2, may simply supply the output from `create_slimMap` as `recomb_map`.  

To clarify, the argument `recomb_map` is used to remap mutations to their actual locations and chromosomes.  This is necessary when data has been simulated over non-contiguous regions such as exon-only data.

In addition to reducing the size of the data, the argument `keep_maf` has practicable applicability as well.  In family-based studies, common SNVs are generally filtered out prior to analysis.  Users who intend to study common variants in addition to rare variants may need to run chromosome specific analyses to allow for allocation of large data sets in `R`.

The following code demonstrates how the `read-slim` function would be called if the `create_slimMap` function was used to create the recombination map for SLiM as in section 2.

```{r, eval =  FALSE, echo = TRUE}
# Let's suppose the output is saved in the 
# current working directory and is named "slimOut.txt".  
# We import the data using the read_slim function.
s_out <- read_slim(file_path  = slimOut.txt, 
                   recomb_map = create_slimMap(hg_exons))


```

Though not displayed here, the `read_slim` function returns a list with 2 items. The first is a data frame named `Mutations`, which catalogs SNV information.  The second item is a sparse matrix named `Genomes`, which contains the haplotype data for all diploid individuals in the simulation.  

We note that importing SLiM data can be time-consuming; importing exon-only mutation data simulated over the 22 human autosomes for a sample of 10,000 individuals on a (computer specs here) took approximately 7 mins.  For the purpose of demonstration, we use the `EXmut` and `EXgen` data sets provided by `SimRVsequences`.

The `EXmut` data set represents the `Mutations` data set returned by `read_slim,` and the `EXgen` data set represents the sparse matrix `Genomes` returned by `read_slim`.

```{r}
#import the EXmut dataset
data(EXmut)
```

```{r}
#view the first 4 observations
head(EXmut, n = 4)
```

The `EXmut` data frame is used to catalog the SNVs in `EXgen`.  The variable `colID` associates the rows of `Mutations` to the columns of `Genomes`, `chrom` identifies the chromosome number, `position` is the position of the SNV in base pairs, `afreq` is the derived allele frequency of each SNV, and `marker` is a unique identified for each SNV.


```{r}
#import the EXgen dataset
data(EXgen)

#dimensions of EXgen
dim(EXgen)
```
Looking at the output above we see that there are 20,000 haplotypes which contian 192 mutations in `EXgen`.

```{r}
#number of rows in EXmut
nrow(EXmut)
```
Since `EXmut` catalogs the SNVs in `EXgen`, `EXmut` will have 192 rows.

```{r}
#View the first 30 mutations of the first 15 haplotypes in EXgen
EXgen[1:15, 1:30]
```

`EXgen` is a sparse matrix of class dgCMatrix.  Entries of `1` represent a mutated allele, while the wild type is represented as `.`.  Recall that we retain SNVs with derived allele frequency less than or equal to `keep_maf`; hence, the majority of entries represent the wild type allele.  


# 5. Select Pool of Causal Variants <a name="CausalVars"></a>

Our next task is to decide which mutations will be modeled as causal variants.  Family-based studies are attractive because of their ability to detect rare causal variation.  However, even family-based studies may not identify a strong association between the disease of interest and a single gene or variant.  When this occurs, one must consider that variation in a pathway, or a set of related genes, may be sufficient to predispose individuals to disease.  We will focus on the latter approach, and note that implementation of a single causal variant is equivalent to a pathway containing a single gene with a single mutation.

Consider a pseudo-apoptosis sub-pathway centered about the TNFSF10 gene based on the 25 genes that have the highest interaction with this gene in the USCS Genome Browser's Gene Interaction Tool [add citation number].  The data for this pseudo-pathway is contained in the `hg_apopPath` data set.

```{r}
# load the hg_apopPath data
data("hg_apopPath")

#View the first 4 observations of hg_apopPath
head(hg_apopPath, n = 4)
```

The `hg_apopPath` data set is similar the `hg_exons` data set discussed in section 2.  However, `hg_apopPath` only catalogs the positions of exons contained in our pseudo-pathway.  

Assuming that the data has been imported using the `read_slim` function, the `identify_pathwaySNVs` function may be used to further refine the `Mutations` data set returned by `read_slim`.  The `identify_pathwaySNVs` function has two arguments:

 1. `markerDF` a data frame containing SNV data, which must be of the same format as the `Mutations` data frame returned by `read_slim`.  
 2. `pathwayDF` A data frame that contains the positions for each exon in the pathway of interest.  This data frame must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `pathwayDF` does not contain any overlapping segments.  All overlapping exons MUST be combined into a single observation. Please execute the command `help(combine_exons)` for more details.*

```{r, eval = TRUE}
# identify variants located in exons contained in our pathway
mutDF <- identify_pathwaySNVs(markerDF  = EXmut,
                              pathwayDF = hg_apopPath)

#View the first 4 observations of mutDF
head(mutDF, n = 4)
```

Upon supplying the `EXmut` data set and a pathway data set, such as `hg_apopPath`, to `identify_pathwaySNVs`, the variable `pathwayRV` is added to `EXmut` and marked TRUE for SNVs located in the pathway of interest.

For `SimRVpedigree`'s ascertainment process to be valid we require the cumulative carrier probability of all causal rare variants to be small, i.e $\le$ 0.002 (cite Nieuwoudt 2017).  To accommodate this assumption we must create an additional variable that identifies causal variants. 

```{r, eval = TRUE}
# tabulate the derived allele frequency of the SNVs located in our pathway
table(mutDF$afreq[mutDF$pathwayRV == TRUE])
```

The output above tabulates variants in our pathway by their derived allele frequency,  For example, our pathway contains 12 SNVs with derived allele frequency 5E-05, 9 SNVs with derived allele frequency 1E-04, and so on.
In total, we can see that there are a variety of SNVs in our pathway to choose from.  To obtain a pool of variants with cumulative allele frequency 0.002, we could choose the SNVs in our pathway with derived allele frequency 5E-05, 1E-04, or 5E-04 to be our causal SNVs.  This could be carried out as follows.

```{r}
# Create a logical variable that is TRUE for SNVs  
# with carrier probability 5e-05, 1e-04, or 5e-04, 
# and FALSE otherwise
keep_RVs_cp <- mutDF$afreq %in% c(5e-05, 1e-04, 5e-04)

# Create the variable 'possibleRV', which is TRUE for SNVs
# in our pathway, with carrier proability 5e-05, 1e-04, or 5e-04;
# and FALSE otherwise
mutDF$possibleRV = ifelse(keep_RVs_cp == TRUE & mutDF$pathwayRV == TRUE,
                          TRUE,
                          FALSE)

# verify that cumulative carrier probability of causal variants is 0.002
sum(mutDF$afreq[mutDF$possibleRV == TRUE])

#determine the number of variants in our pool of causal variants
sum(mutDF$possibleRV == TRUE)
```

From the output above we see that we have selected a pool of 22 causal variants in our pathway with cumulative allele frequency 0.002. 

```{r}
#view first 4 observations of mutDF
head(mutDF, n = 4)
```

The `sim_RVstudy` function (discussed in section 6) will use the variable `possibleRV` to identify potential familial causal variants.  We then sample familial causal rare variants from this pool so that different families segregate different rare variants. Upon identifying the familial rare variant we then sample haplotypes for each founder from the distribution of haplotypes conditioned on the founder's rare variant status at the familial disease locus.  This ensures that the causal rare variant is introduced by the correct founder.
 

# 6. Pedigree Data <a name="PedSample"></a>

The R package `SimRVPedigree` [3] is used to simulate pedigrees ascertained for multiple disease-affected relatives.  For the purpose of illustration we will use the data set `EgPeds`, which is included with `SimRVPedigree` to serve as our sample of ascertained pedigrees.  To learn more about simulating pedigrees with `SimRVPedigree` please refer to `SimRVPedigree`'s documentation and vignette. 


```{r}
# load the SimRVPedigree library
library(SimRVPedigree)

# import the EgPeds dataset
data(EgPeds)

# view first 4 obsetvations of EgPeds
head(EgPeds, n = 4)
```


# 7. Simulate Sequence Data <a name="SimSeq"></a>
Simulating sequence data for ascertained pedigree is achieved with `sim_RVstudy`.  The `sim_RVstudy` function has 6 arguments:

1. `ped_files` A data frame containing study pedigrees.
2. `marker_map` A data frame of SNV data.
3. `haplotype_dist` Genotype data
4. `affected_only` a logical variable.  When `affected_only = TRUE`, data is only simulated for affected individuals and the family members that connect them.  When `affected_only = FALSE` sequence data is simulated for the entire pedigree. By default, `affected_only = TRUE`.
5. `gamma_params` describe.... By default, `gamma_params = c(4/7, 2)`.
6. `burn-in` describe...  By default, `burn_in = 1000`.

Assuming users have followed the steps outlined in the previous sections, we may call `sim_RVstudy` as follows.

```{r}
# simualte sequence using sim_RVstudy
study_seq <- sim_RVstudy(ped_files = EgPeds, 
                         marker_map = mutDF,
                         haplotype_dist = EXgen)

# view summary of output
summary(study_seq)

```

From the above output we see that `sim_RVstudy` returns two items: a sparse matrix named `ped_genos` and a data frame named `geno_map`.   


```{r}
# view part of ped_genos
study_seq$ped_genos[1:15, 1:30]

```

The `ped_genos` output contains the haplotypes for the  individuals in `ped_files`.  If `affected_only = TRUE`, this matrix will contain data for affected individuals and obligate carriers only.  If `affected_only = FALSE` `ped_genos` contains the haplotype data for all individuals in `ped_files`.  The data for founding individuals is drawn from `haplotype_dist`.  The data for non-carriers is obtained by preferential gene-drop (cite paper2 preprint).

```{r}
# view the first observations in geno_map
head(study_seq$geno_map)
```

The `geno_map` data frame is used to map the haplotypes (i.e. rows) in `ped_genos` to the individuals in `ped_files`.  Notice that in the output above individual 1 from family 1 is listed in rows 1 and 2, and individual 2 from family 1 is listed in rows 3 and 4.  This is because the genetic material inherited from each parent is stored in its own row.  The first row represents the material inherited from the father, while the second row represents the material inherited from the mother.

Importing exon-only sequence data from slim output took approximately 6.9 minutes.
Simulating exon-only sequence data for 200 pedigrees on (insert computer specs here) took approximately 1.15 minutes (affected-only).


# 8. References <a name="Ref"></a>

[1] Benjamin C. Haller and Philipp W. Messer (2017). **Slim 2: Flexible, interactive forward genetic simulations**. Molecular
Biology and Evolution; 34(1), pp. 230-240.

[2] Kelley Harris and Rasmus Nielsen (2016). **The genetic cost of neanderthal introgression**. Genetics, 203(2): pp. 881-891.

[3] Christina Nieuwoudt and Jinko Graham (2018). 
  **SimRVPedigree: Simulate Pedigrees Ascertained for a Rare Disease.** 
  *R package version 0.1.0*
   https://CRAN.R-project.org/package=SimRVPedigree.

[4] Ellen M. Wijsman (2012). 
  *The role of large pedigrees in an era of high-throughput sequencing*. 
  Human Genetics 131, pp. 1555-1563.
  
[5] Karolchik, D., Hinrichs, A. S., Furey, T. S., Roskin, K. M., Sugnet, C. W., Haussler, D., and Ken, W. J. (2004). The UCSC Table Browser data retrieval tool. *Nucleic Acids Res*.

[6] Kent, W. J., Sugnet, C. W., Furey, T. S., Roskin, K. M., Pringle, T. H., Zahler, A. M., and Haussler, D. (2002). The human genome browser at UCSC. *Genome Res*, 12(6):996-1006.

[7] Poon, H., Quirk, C., DeZiel, C., and Heckerman, D. (2014). Literome: Pubmed-scale genomic knowledge base in the cloud. *Bioinformatics*, 30:2840-2842.

---
title: "SimRVSequences"
author: "Christina Nieuwoudt and Jinko Graham"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 2
setspace: doublespacing
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body{ /* Normal  */
   font-size: 12px;
}
</style>

# 1. Introduction

Family-based studies are more attractive than case-control studies because they have more power to detect causal rare variants, require smaller sample sizes, and can more accurately detect sequencing errors [9].  However, data collection for these studies is both time consuming and expensive. Furthermore, evaluating methodology to identify causal rare variants requires simulated data. In this vignette we illustrate how the methods provided by `SimRVSequences` may be used to to simulate single-nucleotide variant (SNV) data for family-based studies of diploid organisms.  

MODEL USED...

Please note: `SimRVSequences` is NOT appropriate for users who wish to:  

1. simulate genotype conditional on phenotype, or
2. simulate inheritance of multiple causal rare variants in the same family.

However, users may use other programs in conjunction with `SimRVSequences` to accomplish one or both of these tasks. For example, `SimRVSequences` can be used to perform a standard gene drop (see appendix). Users could then use another program to simulate phenotype given a multilocus genotype (i.e, OpenMendel, RarePedSim??? check on this.)  


# 2. User Requirements
To simulate sequence data for family based studies users are expected to provide:

1. a sample of ascertained pedigrees, and 
2. single-nucleotide variant (SNV) data from a sample of unrelated individuals representing the population of pedigree founders.
 
Presently, we streamline this process for pedigrees simulated by the `R` package `SimRVPedigree` [6] and exon-only SNV data produced by SLiM [2]. The flow chart in Figure 1 illustrates the preparation required for each of the above inputs.  We note that simulation of SNV data with SLiM is NOT accomplished in `R`.  However, we do provide pre and post processing methods to assist with importing and formatting the SNV data simulated by SLiM.  

![**Figure 1.** Data preparation flow chart.  Tasks completed in `R` are enclosed in rectangular frames while the SLiM simulation component is enclosed in a parallelogram.](C:/Users/cnieuwoudt/Documents/SimRVSequences/vignettes/flowchart.png)

In section 4 we demonstrate how the methods provided by `SimRVSequences` can aide in the preparation of the SNV data, and in section 5 we briefly review simulating pedigree data using the `SimRVPedigree` package.

# 3. `SimRVSequences` Assumptions

1. Given a sample of ascertained pedigrees we allow families to segregate different rare variants, but assume that within a family genetic cases are due to a single, **causal rare variant (cRV)** that increases disease susceptibility.  We assume that only one copy of the familial cRV is introduced to the pedigree and that the cRV status of every pedigree member is known.  The `R` package `SimRVPedigree` [6] may be used to simulate pedigrees that meet these criteria (see section 5).
2. Founder haplotypes are sampled from a user-specified, population distribution of haplotypes conditioned on their cRV status.
3. We use a conditional gene-drop algorithm to model inheritance from parent to offspring, which can be described as follows.
  * Simulation of Gametes
    1. Following [8], we model the distance between chiasmata by a gamma distribution.  The default parameter settings, `shape = 2.63` and `rate = 2*2.63`, are used to model genetic recombination with chiasmata interference.  To model recombination without chiasmata interference, i.e. according to Haldane's model, set `shape = 1` and `rate = 2`.
    2. We assume no chromatid interference so that non-sister chromatids are equally likely to participate in a crossover event.
    3. To simulate the formation of gametes we assume that homologous chromatids are assigned to one of four gamete cells with equal probability.  This assignment occurs independently for non-homologous chromosomes.
  * We use a conditional gene drop algorithm to determine which of the four gametes is transmitted from parent to offspring by considering the cRV status of the parent and the offspring, as follows.
    + Case 1: If **both the parent and offspring carry the cRV** we sample the inherited gamete from the two possible parental gametes that carry the cRV. For example, in the father to offspring transmission in Figure 2, we choose from the paternal gametes represented by the top two chromatids.
    + Case 2: If the **parent carries the cRV but the offspring does not**, we sample the inherited gamete from the two possible parental gametes that do not carry the cRV. For example, in the father to offspring transmission in Figure 2, we choose from the paternal gametes represented by the bottom two chromatids.
    + Case 3: If the **parent is not a carrier of the cRV**, then the cRV status of the offspring is irrelevant for this parent's transmission because the offspring cannot inherit it from this parent.  In this scenario, we sample the inherited gamete from the four parental gametes with equal probability.  For example, this would be the case in the mother to offspring transmission in figure 2, since she is not a carrier of the cRV.

![**Figure 2.**  A family trio with possible maternal and paternal recombinant chromatids for a diploid organism with a single set of homologous chromosomes. The cRV locus is indicated by a dashed vertical line over the chromatids, and the cRV is indicated by a black vertical bar within the chromatids.  The top two chromatids of the father contain the only copies of the cRV.](C:/Users/cnieuwoudt/Documents/SimRVSequences/vignettes/singlechromgametes.png)

# 4. Single Nucleotide Variant Data

Before we can simulate sequence data for a sample of pedigrees, we require single nucleotide variant (SNV) data for the pedigree founders. There are several publicly available programs which can aide in this task (e.g. msprime and fastsimcoal), however, we have found the Eiods program SLiM [2] to be the most practical for simulation of genome-wide, exon-only SNV data for a large number of unrelated individuals.   

One of SLiM's many features is that it simulates recombination hotspots using a user-specified recombination map.  This recombination map may be utilized to simulate mutations over unlinked regions (i.e. in different chromosomes) or in linked but non-contiguous regions (i.e in exon-only data).  In section 4.1 we demonstrate how the `create_slimMap` function may be used to generate the recombination map required by SLiM to simulate exon-only SNV data over the entire human genome.

After simulating SNV data with SLiM, users may import the simulated data to `R` using the `read_slim` function. This task is demonstrated in section 4.2.

Finally, in section 4.3 we demonstrate how users may implement a pathway approach by specifying a pool of rare variants from which to select causal familial variants.

## 4.1 Create Recombination Map to Simulate Genome-Wide, Exon-Only Data with SLiM

The `SimRVSequences` function `create_slimMap` simplifies the task of creating the recombination map required by SLiM to simulate exon-only SNV data.  The `create_slimMap` function has three arguments:

1. `exon_df`: A data frame that contains the positions of each exon to simulate.  This data frame must contain the variables `chrom`, `exonStart`, and `exonEnd`.   *We expect that `exon_df` does not contain any overlapping segments.  Prior to supplying exon data to `create_slimMap` users must combine overlapping exons into a single observation.  The `combine_exons` function may be used to accomplish this task (see appendix for details).*
2. `mutation_rate`: the per site per generation mutation rate, assumed to be constant across the genome. By default, `mutation_rate= 1E-8`, as in [3].
3. `recomb_rate`: the per site per generation recombination rate, assumed to be constant across the genome.   By default, `recomb_rate= 1E-8`, as in [3].  

We will illustrate usage of `create_slimMap` using the `hg_exons` data set.

```{r}
# load the SimRVSequences library
library(SimRVSequences)

# load the hg_exons dataset
data("hg_exons")

# print the first four rows of hg_exons
head(hg_exons, n = 4)
```

As seen in the output above, the `hg_exons` data set catalogs the position of each exon in the 22 human autosomes. The data contained in `hg_exons` was collected from the hg 38 reference genome with the UCSC Genome Browser [4, 5]. The variable `chrom` is the chromosome on which the exon resides, `exonStart` is the position of the first base pair in the exon, and `exonEnd` is the position of the last base pair in the exon.  The variable `NCBIref` is the NCBI reference sequence accession numbers for the coding region in which the exon resides.  In `hg_exons` overlapping exons have been combined into a single observation. When exons from genes with different NCBI accession numbers have been combined the variable `NCBIref` will contain multiple accession numbers, each separated by a comma.  We note that different accession numbers may exist for transcript variants of the same gene.


Since the exons in `hg_exons` have already been combined into non-overlapping segments, we supply this data frame to `create_slimMap`.

```{r}
# create recombination map for exon-only data using the hg_exons dataset 
s_map <- create_slimMap(exon_df = hg_exons)

# print first four rows of s_map 
head(s_map, n = 4)
```


The `create_slimMap` function returns a data frame with several variables:

1. `chrom`:  the chromosome number.
2. `segLength`: the length of the segment in base pairs.  *We assume that segments contain the positions listed in `exonStart` and `exonEnd.`  Therefore, for a combined exon segment, `segLength` is calculated as `exonEnd - exonStart + 1.`*
3. `recRate`: the per site per generation recombination rate.  Following [3], segments between exons on the same chromosome are simulated as a single base pair with `rec_rate` equal to recombination rate multiplied by the number of base pairs in the segment.  For each chromosome, a single site is created between the last exon on the previous chromosome and the first exon of the current chromosome.  This site will have recombination rate 0.5 to accommodate unlinked chromosomes.
4. `mutRate`: the per site per generation mutation rate.  Since we are interested in exon-only data, the mutation rate outside exons is set to zero.
5. `exon`: logical variable, `TRUE` if segment is an exon and `FALSE` if not an exon. 
6. `simDist`: the simulated exon length, in base pairs. When `exon = TRUE`, `simDist = segLength`; however, when `exon = FALSE`, `simDist = 1`.
7. `endPos`: The simulated end position, in base pairs, of the segment.


The first row in the output above contains information about the genetic segment **before the first exon** on chromosome 1.  Referring back to the `hg_exons` data we see that the first exon begins at position 11,874.  Since the region before the first exon contains 11,873 base pairs `segLength = 11873` for this region.  To avoid unnecessary computation in SLiM, `simDist = 1` so that this non-exonic region is simulated as a single base pair. The recombination rate for this segment is set to zero.  However, the first non-exon segment for the next chromosome will be 0.5 so that chromosomes are unlinked.  The mutation rate for this non-exon segment is set to zero since we are interested in exon-only data.   

The second row of the output catalogs information for the first exon on chromosome 1.  This exon contains 354 base pairs, hence `simDist` for this segment is 354.  The per site per generation mutation and recombination rates for this exon are both 1E-08.

The third row contains the information for the second non-exon segment on chromosome 1. This segment contains 385 base pairs. Notice that like the first non-exon segment (i.e. row 1) we simulate this segment as a single site, i.e. `simDist = 1`.  However, we set the recombination rate to `segLength` multiplied by the argument `recomb_rate` (i.e. 385*1E-8 = 3.85E-6).

Only three of the variables returned by `create_slimMap` are required by SLiM to simulate exon-only data: `recRate`, `mutRate`, and `endPos`.  The other variables seen in the output above are used by the `read_slim` function to remap mutations to their correct positions when importing SLiM data to `R` (see section 4.2). 

SLiM is written in a scripting language called Eidos. Unlike an `R` array, the first position in an Eidos array is 0.  Therefore, we must shift the variable `endPos` forward 1 unit before supplying this data to SLiM.

```{r}
# restrict output to the variables required by SLiM
slimMap <- s_map[, c("recRate", "mutRate", "endPos")]

# shift endPos up by one unit
slimMap$endPos <- slimMap$endPos - 1

# print first four rows of slimMap 
head(slimMap, n = 4)
```

We use SLiM to generate neutral mutations in exons and allowed them to accumulate over 44,000 generations, as in [3].  However, SLiM is incredibly versatile and can accommodate many different types of simulations.  The creators of SLiM provide excellent resources and documentation to simulate forwards-in-time evolutionary data, which can be found at the SLiM website: https://messerlab.org/slim/.

## 4.2. Import SLiM Data to `R`

To import SLiM data to `R`, we provide the `read_slim` function, which has been tested for SLiM versions 2.0-3.1.  Presently, the `read_slim` function is only appropriate for data produced by the outputFull() method in SLiM.  We do not support output in MS or VCF data format (i.e. produced by outputVCFsample() or outputMSSample()).

Please also note that we currently only permit for SNV data (i.e. 0/1 mutations).

The `read_slim` function has four arguments:

1. `file_path`: The file path of the .txt output file created by the outputFull() method in SLiM.
2. `recomb_map`: (Optional) A recombination map of the same format as the data frame returned by `create_slimMap`.  Users who followed the instructions in section 4.1, may supply the output from `create_slimMap` to this argument. 
3. `keep_maf`: The largest allele frequency for retained SNVs, by default `keep_maf = 0.01`.  All variants with allele frequency greater than `keep_maf` will be removed. Please note, removing common variants is recommended for large data sets due to the limitations of data allocation in R.
4. `pathway_df`: (Optional) A data frame that contains the positions for each exon in a pathway of interest.  This data frame must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `pathwayDF` does not contain any overlapping segments.  Users may combine overlapping exons into a single observation with the `combine_exons` function (see appendix for details).*

To clarify, the argument `recomb_map` is used to remap mutations to their actual locations and chromosomes.  This is necessary when data has been simulated over non-contiguous regions such as exon-only data.  If `recomb_map` is not provided, we assume that the SNV data has been simulated over a contiguous segment starting with the first base pair on chromosome 1.

In addition to reducing the size of the data, the argument `keep_maf` has practicable applicability as well.  In family-based studies, common SNVs are generally filtered out prior to analysis.  Users who intend to study common variants in addition to rare variants may need to run chromosome specific analyses to allow for allocation of large data sets in `R`.

The data frame `pathway_df` allows users to identify SNVs located within a pathway of interest when importing the data.  For example, consider a pseudo-apoptosis sub-pathway centered about the TNFSF10 gene based on the 25 genes that have the highest interaction with this gene in the UCSC Genome Browser's Gene Interaction Tool [4, 5, 7].  The data for this pseudo-pathway is contained in the `hg_apopPath` data set.

```{r}
# load the hg_apopPath data
data("hg_apopPath")

#View the first 4 observations of hg_apopPath
head(hg_apopPath, n = 4)
```

The `hg_apopPath` data set is similar the `hg_exons` data set discussed in section 4.1.  However, `hg_apopPath` only catalogs the positions of exons contained in our pseudo-pathway.

The following code demonstrates how the `read_slim` function would be called if `create_slimMap` was used to create the recombination map for SLiM as in section 4.1.

```{r, eval =  FALSE, echo = TRUE}
# Let's suppose the output is saved in the 
# current working directory and is named "slimOut.txt".  
# We import the data using the read_slim function.
s_out <- read_slim(file_path  = "slimOut.txt", 
                   recomb_map = create_slimMap(hg_exons),
                   pathway_df = hg_apopPath)
```

Though not displayed here, the `read_slim` function returns a list with 2 items. The first is a data frame named `Mutations`, which catalogs SNV information.  The second item is a sparse matrix named `Haplotypes`, which contains the haplotype data for unrelated, diploid individuals.  

We note that importing SLiM data can be time-consuming; importing exon-only mutation data simulated over the 22 human autosomes for a sample of 10,000 individuals on a Windows OS with an i7-4790 @ 3.60GHz and 12 GB of RAM took approximately 3 mins.  For the purpose of demonstration, we use the `EXmuts` and `EXhaps` data sets provided by `SimRVsequences`.

For a small simulation, over restricted regions of the human genome, the `EXmuts` data set represents the `Mutations` data frame returned by `read_slim,` and the `EXhaps` data set represents the sparse matrix `Haplotypes` returned by `read_slim`.

```{r}
#import the EXmuts dataset
data(EXmuts)

#view the first 4 observations
head(EXmuts, n = 4)
```

The `EXmuts` data frame is used to catalog the SNVs in `EXhaps`.  Each row in `EXmuts` represents an SNV.  The variable `colID` associates the rows in `EXmuts` to the columns of `EXhaps`, `chrom` is the chromosome the SNV resides in, `position` is the position of the SNV in base pairs, `afreq` is the derived allele frequency of the SNV, `marker` is a unique character identifier for the SNV, and `pathwaySNV` identifies SNVs located within the pseudo-pathway as `TRUE`.

```{r}
#import the EXhaps dataset
data(EXhaps)

#dimensions of EXhaps
dim(EXhaps)
```
Looking at the output above we see that there are 20,000 haplotypes which contain 500 mutations in `EXhaps`.

```{r}
#number of rows in EXmuts
nrow(EXmuts)
```
Since `EXmuts` catalogs the SNVs in `EXhaps`, `EXmuts` will have 500 rows.

```{r}
#View the first 30 mutations of the first 15 haplotypes in EXhaps
EXhaps[1:15, 1:30]
```

From the output above, we see that `EXhaps` is a sparse matrix of class dgCMatrix.  The `Matrix` package [1] is used to create sparse matrices.  Entries of `1` represent a mutated allele, while the wild type is represented as '`.`'.  Recall that we retain SNVs with derived allele frequency less than or equal to `keep_maf`; hence, the majority of entries represent the wild type allele.  


## 4.3 Select Pool of Causal Variants

Our next task is to decide which mutations will be modeled as causal variants.  We will focus on a pathway approach, which allows for causal variation in a pathway, or a set of related genes, but note that implementation of a single causal variant is equivalent to a pathway containing a single gene with a single mutation.

For `SimRVpedigree`'s ascertainment process to be valid we require the probability that a random individual carries a risk allele to be small, i.e $\le$ 0.002 **(cite SCFBM Nieuwoudt after published)**.

Consider a set of $n$ causal SNVs with derived allele frequencies $p_1, p_2, ..., p_n$, and let $p_{tot} = \sum_{i=1}^n p_i$.  For sufficiently rare SNVs, we may compute the cumulative carrier probability as $p_{tot}^2 + 2*p_{tot}(1-p_{tot})$.

To satisfy the condition $p_{carrier} \le 0.002$, we require that $1 - (1 - p{tot})^2 \le 0.002$, or that $p_{tot} \le 0.001$.

We now demonstrate how users may create a new variable that identifies causal SNVs.
```{r}
# tabulate the derived allele frequencies 
# of the SNVs located in our pathway
table(EXmuts$afreq[EXmuts$pathwaySNV == TRUE])
```

The output above tabulates variants in our pathway by their derived allele frequencies,  For example, our pathway contains 12 SNVs with derived allele frequency 5e-05, 4 SNVs with derived allele frequency 1e-04, 6 SNVs with derived allele frequency 0.00015, and so on.  In total, we can see that there are a variety of SNVs in our pathway to choose from.

To obtain a pool of variants with $p_{tot} \sim 0.001$, let's choose the 12 SNVs with derived allele frequency 5e-05, and 4 SNVs with derived allele frequency 1e-4 to be our causal SNVs, so that $p_{tot} = 12(5\times10^{-5}) + 4(1\times10^{-4}) = 0.001$.

```{r}
# Create the variable 'is_CRV', which is TRUE for SNVs
# in our pathway with derived allele frequncy 5e-05 or 1e-04,
# and FALSE otherwise
EXmuts$is_CRV <- EXmuts$pathwaySNV & EXmuts$afreq %in% c(5e-5, 1e-04)

# verify that sum of the derived allele 
# frequencies of causal SNVs is 0.001
sum(EXmuts$afreq[EXmuts$is_CRV])

#determine the number of variants in our pool of causal variants
sum(EXmuts$is_CRV)
```

From the output above we see that we have selected a pool of 16 causal variants from our pathway with a cumulative allele frequency of 0.001. 

```{r}
#view first 4 observations of EXmuts
head(EXmuts, n = 4)
```

The `sim_RVstudy` function (discussed in section 6) will sample a causal variant for each family in the study from the SNVs for which `is_CRV = TRUE`, so that different families may segregate different rare variants. Upon identifying the familial cRV we then sample haplotypes for each founder from the distribution of haplotypes conditioned on the founder's cRV status.  This ensures that the cRV is introduced by the correct founder.
 

# 5. Pedigree Data <a name="PedSample"></a>

The R package `SimRVPedigree` [6] is used to simulate pedigrees ascertained for multiple disease-affected relatives.  The following example demonstrates how users could use `SimRVPedigree` to simulate five pedigrees ascertained for multiple disease-affected relatives.  

```{r, echo=FALSE, eval=TRUE}
data("study_peds")
```
```{r, echo = TRUE, eval = FALSE}
# load the SimRVPedigree library
library(SimRVPedigree)

#Create hazard object from AgeSpecific_Hazards data
data(AgeSpecific_Hazards)
my_HR = hazard(AgeSpecific_Hazards)

# load libraries needed to simulate pedigrees in parallel.
library(doParallel)
library(doRNG)

npeds <- 5    #set the number of pedigrees to generate

cl <- makeCluster(2)   # create cluster
registerDoParallel(cl) # register cluster


#simulate a sample of five pedigrees using foreach
study_peds = foreach(i = seq(npeds), .combine = rbind,
                  .packages = c("SimRVPedigree"),
                  .options.RNG = 844090518
) %dorng% {
  # Simulate pedigrees ascertained for at least three disese-affected individuals,
  # according to the age-specific hazard rates in the `AgeSpecific_Hazards` data
  # set, ascertained from 1980 to 2010, with seed-founder birth year spanning
  # from 1900 to 1920, stop year set to 2018, and with genetic relative-risk 50.
  sim_RVped(hazard_rates = my_HR,
            GRR = 50, FamID = i,
            RVfounder = TRUE,
            founder_byears = c(1900, 1920),
            ascertain_span = c(1980, 2010),
            stop_year = 2018,
            recall_probs = c(1, 0.5, 0),
            num_affected = 3)[[2]]}

stopCluster(cl) #shut down cluster
```
```{r, fig.height = 8, fig.width = 8.6}
# Plot the pedigree with FamID 3
plot(study_peds[study_peds$FamID == 3, ],
     ref_year = 2018)
```

According to the legend, disease-affected individuals (IDs 1, 3, 8, and 21) are indicated by a solid shading in the upper left third of their symbol.  The proband (ID 21) is indicated by shading in the lower portion of his symbol. Individuals who have inherited the cRV (IDs 1, 3, 5, 6, 7, 8, 21 and 42) are indicated by shading in the upper right portion of their symbol.

The seed founder (ID 1) and all of his descendants have age data relative to the reference year, which is displayed below their symbols.  If a descendant has died by the reference year (IDs 1, 3, 5, 6, etc.) their year of birth and death are displayed in parentheses, and their symbol will have a diagonal line over it. Descendants who are still alive at the reference year have an age identifier.  Descendants who have experienced disease-onset by the reference year will have a disease onset age identifier.


```{r}
#View the first 4 rows of study_peds
head(study_peds, n = 4)
```

The columns displayed in the output above are described as follows:

 1. `FamID`: family identification number 
 2. `ID`: individual identification number
 3. `sex`: sex identification variable: `sex = 0` for males, and `sex = 1` females. 
 4. `dadID`: identification number of father
 5. `momID`: identification number of mother
 6. `affected`: affection status: `affected = TRUE` if individual has developed disease, and `FALSE` otherwise.
 7. `DA1`: paternally inherited allele at the cRV locus: `DA1 = 1` if the cRV is present, and `0` otherwise.
 8. `DA2`: maternally inherited allele at the cRV locus: `DA2 = 1` if the cRV is present, and `0` otherwise.
 9. `birthYr`: the individual's birth year.
 10. `onsetYr`: the individual's year of disease onset, when applicable, and `NA` otherwise.
 11. `deathYr`: the individual's year of death, when applicable, and `NA` otherwise.
 12. `RR`: the individual's relative-risk of disease.
 13. `available`: availability status: `available = TRUE` if individual is recalled by proband, and `FALSE` otherwise.  We note that, by default, all marry-ins are unavailable since we do not simulate life events for marry-ins.
 14. `Gen`: the individual's generation number relative to the eldest pedigree founder.  That is, the seed founder will have `Gen = 1`, his or her offspring will have `Gen = 2`, etc. 
 15. `proband`: a proband identifier: `proband = TRUE` if the individual is the proband, and `FALSE` otherwise.

Not all of the variables above are required to simulate sequence data; the required variables are: `FamID`, `ID`, `sex`, `dadID`, `momID`, `affected`, `DA1`, and `DA2`.  Please note, if `DA` and `DA2` are not provided, a standard gene drop is performed instead of the condition gene drop described in section 3.

To learn more about simulating pedigrees with `SimRVPedigree` please refer to `SimRVPedigree`'s documentation and vignette.

# 6. Simulate Sequence Data 
Simulating sequence data for a sample of ascertained pedigrees is achieved with `sim_RVstudy`.  The `sim_RVstudy` function has the following required and optional arguments:

Required Arguments:

1. `ped_files` A data frame of pedigrees.  This data frame must contain the variables:  `FamID`, `ID`, `sex`, `dadID`, `momID`, `affected`, `DA1`, and `DA2`. See section 5 for more details.
2. `haplos` A sparse matrix of haplotype data, which contains the haplotype data for a sample of unrelated individuals.  Rows are assumed to be haplotypes, while columns represent SNVs.  If `read_slim` was used to import data, users may supply the sparse matrix `Haplotypes` returned by `read_slim`.   
3. `SNV_map` A data frame cataloging the SNV data in `haplos`. The rows of `SNV_map` provide information on the SNVs in `haplos.`  If `read_slim` was used to import data, the data frame `Mutations` returned by this function is of the proper format (see section 4.2).  We note that users must add the variable `is_CRV` to this data frame, as discussed in section 4.3.  If the variable `is_CRV` is not included a standard gene drop is performed in lieu of the conditional gene drop described in section 3.

Optional Arguments:

4. `affected_only` A logical argument.  When `affected_only = TRUE`, data is simulated only for affected individuals and the family members that connect them on a line of descent.  When `affected_only = FALSE` sequence data is simulated for the entire pedigree. By default, `affected_only = TRUE`.
5. `remove_wild` A logical argument that determines if SNVs not carried by any member of the study should be removed from the data.  By default, `remove_wild = TRUE` so that such SNVs are removed from the data.
6.  `pos_in_bp` is a logical variable which indicates if the positions in `SNV_map` are listed in base pairs.  Set `pos_in_bp = TRUE`, if the the positions in `SNV_map` are specified in base pairs. If the positions in `SNV_map` are listed in centiMorgan set `pos_in_bp = FALSE` instead.
7. `gamma_params` The respective shape and rate parameters of the gamma distribution used to simulate distance between chiasmata.  By default, `gamma_params = c(2.63, 2*2.63)`, as in [8].
8. `burn-in` The burn in distance in centiMorgan, used to simulate the location of the first chiasmata. By default, `burn_in = 1000`, as in [8** cite software** ??].

Assuming readers have followed the steps outlined in sections 4 and 5, we may execute the `sim_RVstudy` function as follows.

```{r}
set.seed(11956)
# simulate SNV data using sim_RVstudy
study_seq <- sim_RVstudy(ped_files = study_peds, 
                         SNV_map = EXmuts,
                         haplos = EXhaps)

# view summary of output
summary(study_seq)
```

From the output above we see that `sim_RVstudy` returns four items: 

 - a sparse matrix named `ped_haplos`, 
 - a data frame named `haplo_map`, 
 - a data frame named `SNV_map`, 
 - and a data frame named `ped_files`. 
 
The data frame `ped_files` returned by `sim_RVstudy` is a potentially reduced set of pedigree files for the original families. Recall that, by default `affected_only = TRUE`, so the pedigrees supplied to this function are reduced to contain only the affected individuals and the individuals who connect them along a line of descent. 

```{r, fig.height = 5, fig.width = 4}
#plot the pedigree for family 3, after sequence data simulation
#Since the affected_only option was used the pedigree will now contain 
#only the affected relatives and the relatives who connect them.
plot(study_seq$ped_files[study_seq$ped_files$FamID == 3, ],
     location = "bottomleft")
```

Comparing the plot above to the plot of the same family in section 5, we can see that the number of relatives for whom we simulate SNV data is far less that the total number of relatives in the ascertained pedigree.

```{r}
#View the first 15 haplotypes in ped_haplos
study_seq$ped_haplos[1:15, ]
```

The `ped_haplos` matrix contains the haplotype data for each individual in the `ped_files` output.

```{r}
#Determine the dimensions of ped_haplos
dim(study_seq$ped_haplos)

#Determine the dimensions of EXhaps
dim(EXhaps)
```

Notice that the number of columns (i.e. mutations) in `ped_haplos` is far less than the number of columns in `EXhaps` (which was supplied to `sim_RVstudy`).  This is because the `remove_wild` setting was used to remove superfluous SNVs from our data.  That is, when no one in the study carries a mutated allele at a SNV locus, that marker is removed from the data.  Since we are focused on rare variation, and since `study_peds` is a very small study containing only five families the reduction in data is quite significant.

```{r}
#View the first 4 observations in SNV_map
head(study_seq$SNV_map, n = 4)
```

The output `SNV_map` catalogs the SNVs, i.e. columns,  in `ped_haplos`.  For example, the first column in `ped_haplos` is a SNV located on chromosome 1 at position 23084822.  

```{r}
# view the first observations in haplo_map
head(study_seq$haplo_map)
```

The `haplo_map` data frame is used to map the haplotypes (i.e. rows) in `ped_haplos` to the individuals in `ped_files`.  Notice that in the output above individual 1 from family 1 is listed in rows 1 and 2, and individual 2 from family 1 is listed in rows 3 and 4.  This is because the genetic material inherited from each parent is stored in its own row.  The first row represents the material inherited from the father, while the second row represents the material inherited from the mother.  Additionally, note the variable `FamRV` contained in `haplo_map`, which identifies each family's causal rare variant by marker name. 

```{r}
# to quickly view the causal rare variant for 
# each family we supply the appropriate columns of 
# haplo_map to unique
unique(study_seq$haplo_map[, c("FamID", "FamRV")])
```

From the output above, we see that only families 1 and 4 are segregating the same causal rare variant. 

To count the total number of SVNs shared among affected relatives in each pedigree we use the `count_affectedRV` function.  To use this function we supply the output returned by `sim_RVstudy` to `count_affectedRV`.

```{r}
# count number of SNVs shared by the affected
# relatives in each pedigree
count_affectedRV(study_seq)
```

Looking at the output above, we see that only one affected relative in family 5 carries a copy of the first marker, 1_23084822.   

```{r}
# caluculate the total number of SNVs shared
# by affected relatives across all families
count_SNVshare <- colSums(count_affectedRV(study_seq)[, -1])
count_SNVshare
```

```{r}
# count number of affected ped pedigree
num_aff <- summary(study_seq$ped_files)$family_info$numAffected

#compute family weight based on number of affected per family
f_weight <- (1/num_aff)/sum(1/num_aff)

# calculate weighted average of number of 
# SNVs shared by affecteds across families
w_mat <- matrix(f_weight, ncol = 5) %*% count_affectedRV(study_seq)[, -1]

data.frame(marker = colnames(w_mat), f_share = as.numeric(w_mat[1, ]))
```

# 7. Timing
**All of the following timing estimates were performed on a Windows OS with an i7-4790 @ 3.60GHz and 12 GB of RAM.**

Importing exon-only sequence data from the text file produced by SLiM's outputFull() method (see section 4.2) required approximately 3 minutes.

To time simulation of sequence data with the `sim_RVstudy` function, we explore the effects of the `affected_only` and `remove_wild` arguments on a sample of 200 fully-ascertained pedigrees each of which contained at least 2 disease-affected relatives.

When `affected_only = TRUE`, sequence data is only simulated for disease-affected relatives and the family members that connect them along a line of descent, otherwise if `affected_only = FALSE` sequence data is simulated for the entire pedigree.  When `remove_wild = TRUE` the size of the data is reduced by removing SNVs not carried by any member of the study from the data; otherwise if `remove_wild = FALSE` no data reduction occurs.

Number of Pedigrees|`affected_only`|`remove_wild`|time (in minutes)
---------|--------|------|--------------
200|TRUE|TRUE|0.83
200|TRUE|FALSE|1.12
200|FALSE|TRUE|6.68
200|FALSE|FALSE|8.84

For the sample of 200 pedigrees used to time `sim_RVstudy`, setting `affected_only = FALSE` resulted in simulation of sequence data for a total of 4874 individuals, when `affected_only = TRUE` the data was reduced to contain a total of 806 individuals.  On average, this resulted in a reduction of 24.25 individuals from each pedigree.

# 8. References

[1] Douglas Bates and Martin Maechler (2018). 
  **Matrix: Sparse and Dense Matrix Classes and Methods**. 
  *R package version 1.2-14*. https://CRAN.R-project.org/package=Matrix

[2] Benjamin C. Haller and Philipp W. Messer (2017). **Slim 2: Flexible, interactive forward genetic simulations**. Molecular
Biology and Evolution; 34(1), pp. 230-240.

[3] Kelley Harris and Rasmus Nielsen (2016). **The genetic cost of neanderthal introgression**. Genetics, 203(2): pp. 881-891.

[4] Karolchik, D., Hinrichs, A. S., Furey, T. S., Roskin, K. M., Sugnet, C. W., Haussler, D., and Ken, W. J. (2004). **The UCSC Table Browser data retrieval tool**. Nucleic Acids Res.

[5] Kent, W. J., Sugnet, C. W., Furey, T. S., Roskin, K. M., Pringle, T. H., Zahler, A. M., and Haussler, D. (2002). **The human genome browser at UCSC**. *Genome Res*, 12(6):996-1006.

[6] Christina Nieuwoudt and Jinko Graham (2018). 
  **SimRVPedigree: Simulate Pedigrees Ascertained for a Rare Disease.** 
  *R package version 0.1.0*. https://CRAN.R-project.org/package=SimRVPedigree.

[7] Poon, H., Quirk, C., DeZiel, C., and Heckerman, D. (2014). **Literome: Pubmed-scale genomic knowledge base in the cloud**. *Bioinformatics*, 30:2840-2842.

[8] Roeland E. Voorrips, Chris A Maliepaard. (2012). **The simulation of meiosis in diploid and tetraploid organisms using various genetic models**. *BMC Bioinformatics*, 13:248.

[9] Ellen M. Wijsman (2012). 
  *The role of large pedigrees in an era of high-throughput sequencing*. 
  Human Genetics 131, pp. 1555-1563.

# 9. Appendix

## 9.1 Standard Gene Drop

## 9.2 The `combine_exons` function

Usage of the `combine_exons` function is illustrated below.

```{r}
#create an example data frame that contains the 
#the variables: chrom, exonStart, and exonEnd
exDat <- data.frame(chrom     = c(1, 1, 1, 2, 2, 2),
                    exonStart = c(1, 2, 5, 1, 3, 3),
                    exonEnd   = c(3, 4, 7, 4, 5, 6))

#View exDat data set
exDat
```

From the output above, we see that the first two exons in chromosome one overlap (i.e. the exons with ranges [1, 3] and [2, 4]), as do all three exons in chromosome two.

```{r}
#supply exDat to combine exons
#and view the results
combine_exons(exDat)
```

After supplying the data to `combine_exons` we see that the segments [1, 3] and [2, 4] on chromosome one have been combined in to a single segment: [1, 4].  Similarly, the three overlapping exons from chromosome two: [1, 4], [3, 5], and [3, 6], have now been combined into the segment [1, 6].

---
title: "SimRVSequences"
author: "Christina Nieuwoudt and Jinko Graham"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
setspace: doublespacing
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body{ /* Normal  */
   font-size: 12px;
}
</style>

<style>
    p {line-height: 3em;}
</style>

# Table of contents
1. [Introduction](#introduction)
2. [Create Recombination Map for SLiM 2.0](#SlimMat)
3. [Import SLiM 2.0 Data](#SlimDat)
4. [Select Pool of Causal Variants](#CausalVars)
5. [Import Pedigrees Simulated for Multiple Disease-Affected Relatives](#PedSample)
6. [Simulate Sequence Data](#SimSeq)
7. [References](#Ref)


# 1. Introduction <a name="introduction"></a>

Family-based studies are attractive because they have more power to detect rare variants, require smaller sample sizes, and can more accurately detect sequencing errors than case-control studies.  However, data collection for these studies is both time consuming and expensive.  

`SimRVSequences` provides methods to simualte sequence data for family-based studies.  To simulate sequence data we require: (1) a sample of ascertained pedigrees and (2) single-nucleotide variant (SNV) data from a sample of unrelated individuals.  At present, we streamline use of pedigrees simualted by `SimRVPedigree` and exon-only SNV data produced by SLiM 2.0 [1].  In this vignette we illustrate how to use the methods provided by `SimRVSequences` to accomplish this task.

# 2. Create Recombination Map for Exon-Only Data with SLiM 2.0 <a name="SlimMap"></a>

With SLiM 2.0 users may specify a recombination map to simulate recombination hotspots.  Additionally, the recombination map can be used to simulate mutations over unlinked regions (i.e. in different chromosomes) or in linked but non-contiguous regions (i.e in exon-only data).  The `create_slimMap` function may be used to create a recombination map to simulate exon-only data with SLiM.  We now illustrate this process using the `hg_exons` dataset.

```{r}
# load the SimRVSequences library
library(SimRVSequences)

# load the hg_exons dataset
data("hg_exons")

# print the first three rows of hg_exons
head(hg_exons, n = 4)
```

As seen in the output above, the `hg_exons` dataset catalogues the position of each exon in the 22 human autosomes.  The variable `chrom` is the chomosome on which the exon resides, `exonStart` is the position of the first base pair in the exon, and `exonStop` is the position of the last base pair in the exon.  The variable `geneName` is the NCBI reference sequence identifier for the gene that the exon resides on.  In `hg_exons` overlapping exons are combined into a single exon; when this occurs variable `geneName` will contain a list of NCBI reference sequence identifiers.


The `create_slimMap` function has three arguments:

1. `exon_df`: A dataframe that contians the positions for each exon of interest.  This dataframe must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `exon_df` does not contain any overlapping segments.  Prior to supplying exon data to `create_slimMap` users must combine overlapping exons into a single observation.*  Furthermore, `exon_df` **must** contain the variables  `chrom`, `exonStart`, and `exonEnd`.  The variable `geneName`, as seen in `hg_exons`, is not required.
2. `mutation_rate`: the per site per generation mutation rate. By default, `mutation_rate= 1E-8`, as in [2].
3. `recomb_rate`: the per site per generation recombination rate.  By default, `recomb_rate= 1E-8`, as in [2]   
 
```{r}
# create recombination map for exon-only data using the hg_exons dataset 
s_map <- create_slimMap(exon_df = hg_exons)

# print first four rows of s_map 
head(s_map, n = 4)
```


The `create_slimMap` function returns a dataframe with several variables, but only three are required by SLiM 2.0 to simulate exon-only data:

1. `recRate`: the per site per generation recombination rate.  For computational efficiency, introns between exons on the same chromosome are simulated as a single base pair with `rec_rate` = recombination rate * number of base pairs in the intron.  For each chromosome, a single intron is created between the last exon on the previous chromosome and the first exon of the current chromosome.  This exon will have recombination rate 0.5, so that exons on separate chromosomes are unlinked. (cite Harris?)
2. `mutRate`: the per site per generation mutation rate.  Since we are interested in exon-only data, the mutation rate in introns is set to zero.
3. `endPos`: The position of the last base pair of the segment. 

The other variables seen in the output above are used to remap mutations to their correct postions after simulation. 

SLiM 2.0 is written in a scripting language called Eidos. Unlike an `R` array, the first position in an Eidos array is 0.  Therefore, we must shift the variable `endPos` forward 1 unit before suppying this data to SLiM 2.0.

```{r}
# restrict output to the variables required by SLiM
slimMap <- s_map[, c(4, 5, 8)]

# shift endPos up by one unit
slimMap$endPos <- slimMap$endPos - 1

# print first four rows of slimMap 
head(slimMap)
```

The creators of SLiM provide excellent resources and documentation to slimulate forwards-in-time evoulutionary data, which can be found at the SLiM website: https://messerlab.org/slim/ .

# 3. Import SLiM 2.0 Data <a name="SlimDat"></a>

To import data simulated by SLiM, we provide the `read_slim` function.  The `read_slim` function is only appropriate for data produced by SLiM's outputFull() method. Presently, we do not support output in MS or VCF format.

The `read_slim` function has three arguements:

1. `file_path`: The file path of the .txt output file created by SLiM 2.0.
2. `keep_maf`: The largest allele frequency for retained SNVs. All variants with allele frequency greater than `keep_maf` will be removed. Please note, removing common variants is recommended for large datasets due to the limitations of data allocation in R.
3. `recomb_map`: A recombination map of the same format as the data frame returned by `create_slimMap`.  Users who followed the instructions in Section 2, may simply supply the default output from `create_slimMap` as `recomb_map`.  

To clarify, the argument `recomb_map` is used to remap mutations to their actual locations and chromosomes.  This is necessary when data has been simulated over non-contiguous regions such as exon-only data.

In addition to reducing the size of the data, the argument `keep_maf` has practible applicability as well.  In family-based studies, common SNVs are generally filtered out prior to analysis.  Users who intend to study common variants in addition to rare variants may need to run analyses separately for different chromosomes to allow for allocation of large data sets.

```{r, eval =  FALSE, echo = TRUE}
# Let's suppose the output is saved in the 
# current working directory and is named "slimOut.txt".  
# We import the data using the read_slim function.
s_out <- read_slim(file_path  = slimOut.txt, 
                   recomb_map = create_slimMap(hg_exons))


```

The datasets `EXmut` and `EXgen` represent data returned by the `read_slim` function, which returns a list contianing twp items.  The first item returned by `read_slim` is called `Mutations` and is of the same format as the `EXmut` dataset. The second item is called `Genomes` and is of the same format as the `EXgen` dataset.

```{r}
#import the EXmut dataset
data(EXmut)

#view the first 4 observations
head(EXmut, n = 4)
```

The `EXmut` dataframe is used to catalogue the SNVs in `EXgen`.  The variable `colID` associates the rows of `Mutations` to the columns of `Genomes`, `chrom` identifies the chromosome number, `position` is the position of the SNV in base pairs, `afreq` is the derived allele frequency of each SNV, and `marker` is a unique identified for each SNV.


```{r}
#import the EXgen dataset
data(EXgen)

#determine class of EXgen
class(EXgen)

#dimensions of EXgen
dim(EXgen)

#View EXgen
EXgen[1:15, 1:30]
```

`EXgen` is a sparse matrix of class dgCMatrix.  Entries of `1` represent a mutated allele, while the wild type is represented as `.`.  Recall that we retain SNVs with derived allele frequency less than or equal to `keep_maf`; hence, the majority of entries represent the wild type allele.  


# 4. Select Pool of Causal Variants <a name="CausalVars"></a>

**VERY SIMILAR TO PAPER.. EDIT THIS**

Now that we have simulated a wide array of mutations over the exons, we must decide which mutations will be modeled as causal rare variants. Family-based studies are attractive because of their ability to detect rare causal variation.  However, even with family-based studies researchers may not be able to identify a strong association between the disease of interest and a single gene or variant.  When this occurs, the next step is to consider that variation in a pathway, or a set of related genes, may be sufficient to predispose individuals to the disease of interest.  We will focus on the latter approach, and note that implementation of a single causal variant is equivalent to a pathway containing a single gene with a single mutation.

When cells become damaged it is biologically advantageous for these cells to be eliminated.  Apoptosis, also known as programmed cell death, is a biological process that destroys damaged or unnecessary cells (cite ThomThom).  Since cancer involves the uncontrolled replication of a damaged cell, it is possible that deleterious mutations in the apoptosis pathway may increase the risk of developing cancer.  We will demonstrate an approach to select variants from an apoptosis-like pathway.  The TNFSF10 gene is a member of the human apoptosis pathway (cite KEGG).  We defined a pseudo-apoptosis sub-pathway centered about TNFSF10 using the 25 genes that had the highest interaction with this gene (citeUCSCGeneInteraction).  The data for this pseudo-pathway is contained in the `hg_apopPath` data set.

```{r}
# load the hg_apopPath data
data("hg_apopPath")

#View the first 4 observations of hg_apopPath
head(hg_apopPath, n = 4)
```

The `hg_apopPath` dataset is similar the `hg_exons` dataset dicussed in section 2.  However, `hg_apopPath` only catalogues the postions of exons contained in our pseudo-pathway.  

The `identify_pathwayRVs` function is used to further refine the `Mutations` data set returned by `read_slim`.  The `identify_pathwayRVs` function has two arguments:

 1. `markerDF` a dataframe containing SNV data, which must be of the same format as the `Mutations` dataframe returned by `read_slim`.  
 2. `pathwayDF` A dataframe that contains the positions for each exon in the pathway of interest.  This dataframe must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `pathwayDF` does not contain any overlapping segments.*

```{r, eval = TRUE}
# identify variants located in exons contained in our pathway
mutDF <- identify_pathwaySNVs(markerDF  = EXmut,
                              pathwayDF = hg_apopPath)

#View the first 4 observations of mutDF
head(mutDF, n = 4)
```

Upon supplying the `EXmut` dataset and a pathway dataset, such as `hg_apopPath`, to `identify_pathwayRVs`, the variable `pathwayRV` is added and marked TRUE for SNVs located in the pathway of interest.

For `SimRVpedigree`'s ascertainment process to be valid we require the cumulative allele frequency of all causal rare variants to be small, i.e $\le$ 0.002 (cite Nieuwoudt 2017).  To accomodate this assumption we must manually identify the pool of causal variants from which each familial rare variant will be selected. 

```{r, eval = TRUE}
# tabulate the derived allele frequency of the SNVs located in our pathway
table(mutDF$afreq[mutDF$pathwayRV])
```

From the output above, we can see that there are a variety of SNVs in our pathway to choose from.  To obtain a pool of variants with cumulative allele frequency 0.002, we could take the following approach.

```{r}
# Select possible causal SNVs from the SNV's in our pathway with 
# derived allele frequency 5e-05, 1e-04, or 5e-04.
mutDF$possibleRV = mutDF$afreq %in% c(5e-05, 1e-04, 5e-04) & mutDF$pathwayRV

# verify that cumulative allele frequency of causal variants is 0.002
sum(mutDF$afreq[mutDF$possibleRV])

#determine the number of variants in our pool of causal variants
length(mutDF$afreq[mutDF$possibleRV])
```

From the output above we see that we have selected a pool of 22 causal variants with cumulative allele frequency 0.002. 
 

# 5. Import/Simulate Pedigrees Simulated for Multiple Disease-Affected Relatives <a name="PedSample"></a>

The R package `SimRVPedigree` [3] is used to simulate pedigrees ascertained for multiple disease-affected relatives.  For the purpose of illustration we will use the dataset `EgPeds`, which is included with `SimRVPedigree`.  To learn more about simulating pedigrees with `SimRVPedigree` please refer to `SimRVPedigree`'s documentation and vignette. 


```{r}
# load the SimRVPedigree library
library(SimRVPedigree)

# import the EgPeds dataset
data(EgPeds)

# view first 4 obsetvations of EgPeds
head(EgPeds, n = 4)
```

*Perhaps we should note which variables are required to simulate sequence data*

# 6. Simulate Sequence Data <a name="SimSeq"></a>

We then sample familial causal rare variants from this pool so that different families segregate different rare variants. Upon identifying the familial rare variant we then sample haplotypes for each founder from the distribution of haplotypes conditioned on the founder's rare variant status at the familial disease locus.  This ensures that the causal rare variant is introduced by the correct founder.  With this simulation tool in hand, researchers can investigate a wide variety of methods to identify causal rare variants in ascertained pedigrees. 


```{r}
study_seq <- sim_RVstudy(ped_files = EgPeds, 
                         marker_map = mutDF,
                         chrom_map = hg_chrom,
                         haplotype_dist = EXgen)
```

# 7. References <a name="Ref"></a>

[1] Benjamin C. Haller and Philipp W. Messer (2017). **Slim 2: Flexible, interactive forward genetic simulations**. Molecular
Biology and Evolution; 34(1), pp. 230-240.

[2] Kelley Harris and Rasmus Nielsen (2016). **The genetic cost of neanderthal introgression**. Genetics, 203(2): pp. 881-891.

[3] Christina Nieuwoudt and Jinko Graham (2018). 
  **SimRVPedigree: Simulate Pedigrees Ascertained for a Rare Disease.** 
  *R package version 0.1.0*
   https://CRAN.R-project.org/package=SimRVPedigree.
  

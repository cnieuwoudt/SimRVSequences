---
title: "Format VCF Files"
author: "Christina Nieuwoudt, Wendy Wang, Brad McNeney, and Jinko Graham"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
vignette: |
  %\VignetteIndexEntry{Format VCF Files} 
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignetteEncoding{UTF-8}{inputenc}
---

<style type="text/css">

body{ /* Normal  */
   font-size: 12px;
}
</style>

# Introduction

ADD INTRODUCTION

NOTE: following only applicable to SNV data - no indels, cnvs, etc.

We are pleased to announce that `SimRVSequences` (>= 0.2.0) features formatted exon-data from the 1000 genomes project.  *Describe data (accessed on, exon only, filtered for..., etc.)*  Additionally, we demonstrate how users can format vcf files which contain genotype data for use with the `sim_RVstudy` function.


TO NOTE:
  * this vignette is intended to for users who wish to format SNP data, and is not intended to format of other types of variants (e.g. indels, cnvs, etc)
  * Format = "GT": Can format be anything other than "GT"?
  * 
  

In this vigentte we demonstrate how to:

1. import a vcf file (see section XX),
2. format haplotype data (see section XX),
3. format mutation data (see section XX), 
4. create an object of class `SNVdata` (see section XX).

Alternatively, we also provide pre-formatted SNV data from .  This data can be obtained using the `import_SNVdata` function, which we demonstrate in section XX.

# Importing VCF files with vcfR

Importing vcf data using vcfR package [2] is accomplished with the `read.vcfR` function.  To import a vcf file the user supplies the file path to the argument `file` of the `read.vcfR` function. For example, suppose the vcf file named "exons_chr21.vcf.gz" was downloaded from https://github.com/cnieuwoudt/1000-Genomes-Exon-Data/tree/master/Exon%20Data and stored in a folder named "Data" in the "C" directory. We import "exons_chr21.vcf.gz" using the `read.vcfR` function as follows:

```{r, echo = FALSE}
load(url("https://github.com/cnieuwoudt/1000-Genomes-Exon-Data/raw/master/Vignette%20Data/vcf_chrom21.rda"))
```
```{r}
# load the vcfR package
library(vcfR)
```
```{r, eval = FALSE}
# specify the file path
vcf_file_path <- "C:/Data/exons_chr21.vcf.gz"

#import vcf file
vcf_chrom21 <- read.vcfR(vcf_file_path)
```
```{r}
# determine the structure of vcf_chrom21
str(vcf_chrom21)
```

From the output above, we see that `vcf_chrom21` is an object of class `vcfR` with 3 slots.  The first slot `@meta` contains meta data for the vcf file; the second slot `@fix` contains the fixed data, which describes the mutations; and the third slot `@gt` contians the genotype data.  We discuss these components in detail in the following sections.  Specifically, in section section XX we discuss genotype data and in section XX we discuss the fixed data and the meta data. For additional information regarding objects of class `vcfR` execute `help("vcfR-class")` in the console.

# Format Haplotype Data{#Haps}

We now demonstrate how to convert the genotype data into haplotype data.  Recall, that the genotype data is stored in the `@gt` slot of the `vcfR` object.  

```{r}
# View the first five rows and columns of the genotype data
vcf_chrom21@gt[1:5, 1:5]
```

From the output above, we see that the first column in `vcf_chrom21@gt` does not contain genotype data, but rather a variable named `FORMAT`.  Following this variable, each column in `vcf_chrom21@gt` represents an individual identified by a unique character string, e.g. "HG00096".  Each row in `vcf_chrom21@gt` represents a SNP.

```{r}
#View first 4 mutations for the individual with ID "HG00096"
vcf_chrom21@gt[1:4, "HG00096"]
```

From the output above, we see that the individual with ID "HG00096"" is homozygous for the reference allele, i.e. "0|0", for the first three SNPs in the genotypes data.  However, for the fourth SNP this individual is heterozygous for the alternate allele, i.e. "0|1".  We note that since this is phased data the genotype "0|1" indicates that this individual inherited the reference allele, "0", from his or her father and the alternate allele, "1", from his or her mother.

```{r}
# Remove the variable named "FORMAT"
# and store the resulting data as genos 
genos <- vcf_chrom21@gt[, -1]

# View the first 5 mutations (i.e. rows) for 
# the first 3 individuals (i.e. columns)
genos[1:5, 1:3]
```

To convert this genotype data to a sparseMatrix we supply the genotypes data to the `genos2sparseMatrix` function, which is included in the `SimRVSequences` package. This function may be used to convert phased genotype data for diplod organisms into a sparse matrix. We note that this conversion makes use of the methods provided with the `Matrix` package [1]. 

```{r}
# load the SimRVSequences library
library(SimRVSequences)

# Convert to sparseMatrix
haplotypes <- genos2sparseMatrix(genotypes = genos)
```

We note that `genos2sparseMatrix` transposes the supplied genotype data.  Thus, in the returned matrix individuals are stored as rows and mutations are stored as columns. Additionally, since this is a diploid population, each individual will have two rows of data.  That is, the haplotype data for the first indivdiual in `genos`, named "HG00096", is stored in rows 1 and 2 of `haplotypes`, the haplotype data for the second indivdiual in `genos`, named "HG00097", is stored in rows 3 and 4 of `haplotypes`, and so on. 

```{r}
# View dimensions of haplotypes
dim(haplotypes)

# View haplotype data for the first  
# 3 diploid individuals and first 5 SNPs
haplotypes[1:6, 1:5]
```

From the output above we see that `haplotypes` is a sparse matrix of class `dgCMatrix`.  Entries of `1` represent a mutated allele, while the wild type is represented as '`.`'.   For additional information regarding objects of class `dgCMatrix` execute `help("dgCMatrix-class")` in the console.

# Format Mutation Data

We now demonstrate how to manipulate the fixed data contained in the `vcfR` object.  Recall, that the fixed data is stored in the `@fix` slot of the `vcfR` object and is used to describe the SNPs in the genotype data. 

```{r}
# View the first five rows of the fixed data
vcf_chrom21@fix[1:5, ]
```

From the output above, we see that the fixed data contains several variables. According to http://www.internationalgenome.org/wiki/Analysis/vcf4.0/ the variables above may be interpreted as follows:

1. `CHROM` is the chromosome number of the SNP
2. `POS` is the position, in base pairs, of the SNP
3. `ID`, when available, a unique identifier for the SNP, e.g. rs numbers for dbSNPs.
4. `REF` is the reference allele for the SNP
5. `ALT` is the alternate allele for the SNP
6. `QUAL`, when available, is a quality score for the alternate allele
7. `FILTER` indicates whether or not the site has passed all filters.  When passing all filters `FILTER = PASS`, otherwise `FILTER` is charater string which contains all non-passing filters.
8. `INFO` contains additional information for each SNP.  Each variable in filter is separated by a semicolon.

Additional information for the variables contained in `INFO` is contained in the metadata for the vcf object.  Recall that meta data in `vcfR` objects is stored in the `@meta` slot.
```{r}
# View the meta data
vcf_chrom21@meta
```

From the output above, we see that the first variable contained in `INFO` is named `AF` and represents the estimated allele frequency for the SNP.

To format the fixed data, including the `INFO` variables, the `vcfR` package offers the `vcfR2tidy` function.  We now demonstrate how to use `vcfR2tidy` to format the fixed data.  For additional information on the `vcfR2tidy` function please execute `help(vcfR2tidy)` in the console.

```{r}
# Extract and store the mutation data using vcfR2tidy
#
# NOTE: setting info_only = TRUE since we do not need 
# to re-process the genotype data
#
# The argument "info_fields" specify which variables to include 
# "info_types" indicates the respective variable type for each
# "info_fields" variable.
muts <- vcfR2tidy(vcf_chrom21, 
                  info_only = TRUE,
                  info_fields = c("AF", "AC", "NS", "AN",
                                  "EAS_AF", "EUR_AF", "AFR_AF", 
                                  "AMR_AF", "SAS_AF", "DP"),
                  info_types = c(AF = "n", AC = "i", NS = "i", AN = "i",
                                 EAS_AF = "n", EUR_AF = "n", AFR_AF = "n", 
                                 AMR_AF = "n", SAS_AF = "n", DP = "i"))

#determine the structure of muts
str(muts)
```

From the output above, we see that `muts` contains the fixed data as a `tbl_df` which inherits from objects of class `data.frame`.  Additionally, `muts` also contains the meta data described previously.

Our `sim_RVstudy` function expects mutation data to formatted as a data frame.  Additionally, mutation data supplied to `sim_RVstudy` must contain the following variables:

1. `colID`: a numeric variable which associates the rows in the mutations data frame to the columns in the haplotype sparse matrix. 
2. `chrom`: represents the chromosome in which the SNP resides.
3. `position`: represents the position of the SNP in base pairs.
4. `afreq`: (Optional) the derived allele frequency of the SNP.

From the previous discussion, we know that the fixed data returned by `vcf2tidy` contains the variables `chrom`, `position`, and `afreq`. To make the output from the `vcf2tidy` function compatible with the format expected for the `sim_RVstudy` function we make the following changes.

```{r}
# store the fixed item in muts data as dataframe 
mutations <- as.data.frame(muts$fix)

# Create the variable colID to identify the column positon of the mutation.
# NOTE: Since mutations have retained their order, we can accomplish this task 
# using the seq function.  Since the mutations are stored in the columns of
# the haplotypes matrix we determine the length of our sequence as the number of 
# columns in haplotypes.
mutations <- cbind(seq(1:dim(haplotypes)[2]), mutations)
head(mutations)
``` 

```{r}
#rename columns for consistency with expected format
#According to muts$meta the variable "AF" is the estimated allele freq,
#i.e. the variable we expect to be named "afreq" in the mutations dataset.
colnames(mutations)[c(1:3, 7)] = c("colID", "chrom", "position", "afreq")
head(mutations)
```

# Create an Object of Class `SNVdata`

The constructor function for objects of class `SNVdata` has three arguments:

1. `Haplotypes` A sparse matrix of haplotype data, which contains the haplotypes for unrelated individuals representing the founder population.
2. `Mutations` A data frame that catalogs the SNPs in the columns of the `Haplotypes` matrix. `Mutations` must include the following variables:

    * `colID`: a numeric variable which associates the rows in `Mutations` to the columns in `Haplotypes`. 
    * `chrom`: represents the chromosomal in which the SNP resides.
    * `position`: represents the chromosomal position of the SNP in base pairs.
    * `afreq`: (Optional) the derived allele frequency of the SNP.
3. `Samples` (Optional) this argument allows users to provide data for the individuals whose haplotypes are stored in `Haplotypes`.

The sample data for the individuals whose genotypes are contained in the vcf file for chromosome 21 can be obtained as follows:

```{r}
file_path <- 'https://raw.githubusercontent.com/cnieuwoudt/1000-Genomes-Exon-Data/master/Vignette%20Data/SampleInfo1.csv'
SampleInfo <- read.csv(file_path)
```

```{r}
#View the first 6 lines of the sample data
head(SampleInfo)
```

From the output above, we see that this data set includes a population description for the individuals as well as information on any relations that are included in this dataset.  Since we are interested in unrelated individuals we want to remove any relatives from the data.  This dataset includes 42 individuals who have been listed as third order or higher relatives.  We reduced the data by randomly sampling one relative from each set of related individuals.  This resulted in the removal of 22 individuals.  Additionally, we removed any individuals from the sample data that were not included vcf data, which resulted in the removal of another 930 individuals. Users interested in following the sample-reduction process may find our script at: https://github.com/cnieuwoudt/SimRVSequences/blob/master/data-raw/format_sample_data.R.

To import the reduced sample data, we execute the following commands:
```{r}
file_path <- 'https://raw.githubusercontent.com/cnieuwoudt/1000-Genomes-Exon-Data/master/Formatted-SNVdata/SampleData.csv'
SampleData <- read.csv(file_path)

# view the first 6 lines of SampleData
head(SampleData)
```

Next, we must reduce the haplotype data to include only the individuals who are contained in SampleData.  We achieve this as follows:

```{r}
# recall that the row names in the haplotypes matrix are the sample IDs
row.names(haplotypes)[1:5]

# Remove the individuals not contained in SampleData
haplotypes <- haplotypes[row.names(haplotypes) %in% SampleData$Sample, ]

# View the new dimensions of haplotypes
dim(haplotypes)
```

Comparing the dimensions above to the dimensions that were seen in section XX \@ref{Haps}, we see that 44 rows have been removed, which corresponds to the removal of 22 diploid individuals.

Finally, we are ready to create an object of class `SNVdata`.  To create this object we supply the required arguments to the `SNVdata` construtor function as follows.

```{r}
#create SNVdata object for chromosome 21 without sample or meta data
SNVdata_chrom22 <- SNVdata(Haplotypes = haplotypes, 
                           Mutations = mutations,
                           Samples = SampleData)
str(SNVdata_chrom22)
```


Note that for rare SNP data this object is much smaller than the `vcfR` object for the same data set.  To determine the size of each of these objects we use the `object_size` function from the `pryr` package. 
```{r}
library(pryr)

# Determine size of vcfR object for chromosome 21
object_size(vcf_chrom21)

# Determine size of SNVdata object for chromosome 21
object_size(SNVdata_chrom22)
```

We note that while the size reduction between the `vcfR` and `SNVdata` object for this chromosome is quite drastic, the size SNVdata object is very similar to the size of the zipped vcf file for chromosome 21.  Even so, we note this format may be very useful for large sparse genomic data sets in R.

# Import 1000 Genomes Exon Data with `import_SNVdata`

The SNVdata objects for each chromosome are stored in the "Formatted-SNVdata" folder in the GitHub repository.

The `import_SNVdata` function allows users to import formatted SNV data for each chromosome.  The `import_SNVdata` function has two arguments:

  1. `chrom` A number or list of numbers that specify which non-sex chromosomes to import.
  2. `pathway_df` (Optional) A data frame that contains the positions for each exon in a pathway of interest.  This data frame must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `pathwayDF` does not contain any overlapping segments.  Users may combine overlapping exons into a single observation with our `combine_exons` function.  For additional information regarding the `combine_exons` function please  execute `help(combine_exons)` in the console.*

```{r}
# load the hg_apopPath dataset
data("hg_apopPath")

#import SNV data for chromosomes 21 and 22 and identify 
#SNPs located in the pathway defined by hg_apopPath 
EXdata = import_SNVdata(21:22, pathway_df = hg_apopPath)

# determine the structure of EXdata
str(EXdata)
```


Note that any SNPs in the pathway contained in the `hg_apopPath` data will be identified by the variable `pathwaySNV` in the `Mutations` data frame of `EXdata`.

```{r}
# View the first 6 SNPs contained in the pathway of interest
head(EXdata$Mutations[EXdata$Mutations$pathwaySNV, ])
```

# References
[1] Douglas Bates and Martin Maechler (2018). 
  **Matrix: Sparse and Dense Matrix Classes and Methods**. 
  *R package version 1.2-14*. https://CRAN.R-project.org/package=Matrix
  
[2] Knaus BJ, Grünwald NJ (2015). 
  **VCFR: a package to manipulate and visualize variant call format data in R.**
  Molecular Ecology Resources, 17(1): 44-53.

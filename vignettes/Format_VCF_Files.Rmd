---
title: "Format VCF Files"
author: "Christina Nieuwoudt, Wendy Wang, and Jinko Graham"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
vignette: "%\\VignetteIndexEntry{Format VCF Files} \n%\\VignetteEngine{knitr::rmarkdown}
  \n%\\VignetteEncoding{UTF-8}{inputenc}\n"
---

<style type="text/css">

body{ /* Normal  */
   font-size: 12px;
}
</style>

```{r wrap-hook, echo =  FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

# Introduction

ADD INTRODUCTION

NOTE: following only applicable to SNV data - no indels, cnvs, etc.

We are pleased to announce that `SimRVSequences` (>= 0.2.0) features formatted exon-data from the 1000 genomes project.  *Describe data (accessed on, exon only, filtered for..., etc.)*  Additionally, we demonstrate how users can format vcf files which contain genotype data for use with the `sim_RVstudy` function.

Filtering Conditions: SNVs only

TO NOTE:
  * this vignette is intended to for users who wish to format SNV data, and is not intended to format of other types of variants (e.g. indels, cnvs, etc)
  * Format = "GT": Can format be anything other than "GT"?
  * 
  

In this vigentte we demonstrate how to:

1. import a vcf file (see section XX),
2. format haplotype data (see section XX),
3. format mutation data (see section XX), 
4. create an object of class `SNVdata` (see section XX).

Alternatively, we also provide pre-formatted SNV data from .  This data can be obtained using the `import_SNVdata` function, which we demonstrate in section XX.

# Format VCF Files 
## Import VCF File

Importing vcf data using the `vcfR` package [2] is accomplished with the `read.vcfR` function.  To import a vcf file the user supplies the file path to the argument `file` of the `read.vcfR` function. For example, suppose the vcf file named "exons_chr21.vcf.gz" was downloaded from https://github.com/simrvprojects/1000-Genomes-Exon-Data/tree/master/Exon%20Data and is stored in a folder named "Data" in the "C" directory. We import "exons_chr21.vcf.gz" using the `read.vcfR` function as follows:

```{r}
# load the vcfR package
library(vcfR)
```
```{r, echo = FALSE}
load(url("https://github.com/simrvprojects/1000-Genomes-Exon-Data/raw/master/Vignette%20Data/vcf_chrom21.rda"))
```
```{r, eval = FALSE}
# specify the file path
vcf_file_path <- "C:/Data/exons_chr21.vcf.gz"

#import vcf file
vcf_chrom21 <- read.vcfR(vcf_file_path)
```
```{r, linewidth = 80}
# determine the structure of vcf_chrom21
str(vcf_chrom21)
```

From the output above, we see that `vcf_chrom21` is an object of class `vcfR` with 3 slots.  The first slot `@meta` contains meta data for the vcf file; the second slot `@fix` contains the fixed data, which describes the mutations contained in the vcf file; and the third slot `@gt` contains the genotype data.  We discuss these components in detail in the following sections.  Specifically, in section section XX we discuss the genotype data and in section XX we discuss the fixed and meta data. For additional information regarding objects of class `vcfR` please execute `help("vcfR-class")` in the console.

## Format Haplotype Data{#Haps}

We now demonstrate how to format the genotype data into haplotype data.  Recall, that the genotype data is stored in the `@gt` slot of the `vcfR` object.  

```{r}
# View the first five rows and columns of the genotype data
vcf_chrom21@gt[1:5, 1:5]
```

From the output above, we see that the first column in `vcf_chrom21@gt` does not contain genotype data, but rather a variable named `FORMAT`.  Following this variable, each column in `vcf_chrom21@gt` represents an individual identified by a unique character string, e.g. "HG00096".  Each row in `vcf_chrom21@gt` represents a SNV.

```{r}
#View first 4 mutations for the individual with ID "HG00096"
vcf_chrom21@gt[1:4, "HG00096"]
```

From the output above, we see that the individual with ID "HG00096" is homozygous for the reference allele, i.e. "0|0", for the first three SNVs in the genotypes data.  However, for the fourth SNV this individual is heterozygous for the alternate allele, i.e. "0|1".  We note that this data is phased so that the genotypes for each individual are ordered.  That is, for a given individual, the first allele may represent the paternally inherited allele while the second may represent the maternally inherited allele and this ordering is consistent in every genotype for this individual.

```{r}
# Remove the variable named "FORMAT"
# and store the resulting data as genos 
genos <- vcf_chrom21@gt[, -1]

# View the first 5 mutations (i.e. rows) for 
# the first 3 individuals (i.e. columns)
genos[1:5, 1:3]
```

To format the genotype data we supply `genos` to the `genos2sparseMatrix` function, which is included in the `SimRVSequences` package. This function may be used to convert phased SNV data for diploid organisms into haplotype data stored as a sparse matrix. We note that this conversion makes use of the methods provided by the `Matrix` package [1]. 

```{r}
# load the SimRVSequences package
library(SimRVSequences)

# Convert to sparseMatrix
haplotypes <- genos2sparseMatrix(genotypes = genos)
```

We note that `genos2sparseMatrix` transposes the supplied genotype data.  Thus, in the returned matrix individuals are stored as rows and mutations are stored as columns. Additionally, since this is a diploid population, each individual will have two rows of data.  That is, the haplotype data for the first individual in `genos`, named "HG00096", is stored in rows 1 and 2 of `haplotypes`, the haplotype data for the second individual in `genos`, named "HG00097", is stored in rows 3 and 4 of `haplotypes`, and so on. 

```{r}
# View haplotype data for the first  
# 3 diploid individuals and first 5 SNVs
haplotypes[1:6, 1:5]
```

From the output above we see that `haplotypes` is a sparse matrix of class `dgCMatrix`.  Entries of `1` represent the alternate or mutated allele, while the reference allele or wild type alelle is represented as '`.`'.   For additional information regarding objects of class `dgCMatrix` execute `help("dgCMatrix-class")` in the console.

## Format Mutation Data

We now demonstrate how to manipulate the fixed data contained in the `vcfR` object.  Recall, that the fixed data is stored in the `@fix` slot of the `vcfR` object and is used to describe the SNVs in the genotype data. 

```{r, linewidth = 80}
# View the first three rows of the fixed data
vcf_chrom21@fix[1:3, ]
```

From the output above, we see that the fixed data contains several variables. According to http://www.internationalgenome.org/wiki/Analysis/vcf4.0/ the variables above may be interpreted as follows:

1. `CHROM` is the chromosome number of the SNV
2. `POS` is the position, in base pairs, of the SNV
3. `ID`, when available, is a unique identifier for the SNV, e.g. an rs number for a dbSNP.
4. `REF` is the reference allele for the SNV
5. `ALT` is the alternate allele for the SNV
6. `QUAL`, when available, is a quality score for the SNV
7. `FILTER` indicates whether or not the site has passed all filters.  When passing all filters `FILTER = PASS`, otherwise `FILTER` is a character string which contains all non-passing filters.
8. `INFO` contains additional information for each SNV.  Each variable in filter is separated by a semicolon.

Additional information for the variables contained in `INFO` is contained in the metadata of the vcf object.  Recall that meta data in `vcfR` objects is stored in the `@meta` slot.
```{r, linewidth = 80}
# View the meta data
vcf_chrom21@meta
```

From the output above, we see that the first variable contained in `INFO` is stored in the eighth item of the meta data and is named `AF`.  From the description, we see that `AF` represents the estimated alternate allele frequency.  From the type, we see that this is a float variable.

To format the fixed data, including the `INFO` variables, the `vcfR` package offers the `vcfR2tidy` function.  We now demonstrate how to use `vcfR2tidy` to format the fixed data.  For additional information on the `vcfR2tidy` function please execute `help(vcfR2tidy)` in the console.

```{r, linewidth = 80}
# Extract and store the mutation data using vcfR2tidy
#
# NOTE: setting info_only = TRUE since we do not need 
# to re-process the genotype data
#
# To include INFO variables, we supply a list of variable 
# names to "info_fields".  The names of these variables must 
# corresponds with the INFO variable names defined in the meta data.
# We specify each variable type, by variable name, using the "info_types" 
# argument.  Each INFO variable type is available in the meta data. Note
# that the info types for float varibles are set to numeric, i.e. "n".
#
muts <- vcfR2tidy(vcf_chrom21, 
                  info_only = TRUE,
                  info_fields = c("AF", "AC", "NS", "AN",
                                  "EAS_AF", "EUR_AF", "AFR_AF", 
                                  "AMR_AF", "SAS_AF", "DP"),
                  info_types = c(AF = "n", AC = "i", NS = "i", AN = "i",
                                 EAS_AF = "n", EUR_AF = "n", AFR_AF = "n", 
                                 AMR_AF = "n", SAS_AF = "n", DP = "i"))

# Determine the structure of muts
str(muts)
```

From the output above, we see that `muts` contains the fixed data, including `INFO` variables as a `tbl_df` which inherits from objects of class `data.frame`. 

```{r, linewidth = 80}
#View the first three rows of the fixed data in muts
head(muts$fix, n = 3)
```

Notice that the alternate allele frequency, `AF`, is rounded to two decimal places.  Users who prefer to retain more that 2 significant digits can re-calculate `AF` as the alternate allele count, i.e. `AC`, divided by the alelle number values, i.e. `AN`.  In this context, the allele number is the total number of samples with non-missing data at the specified marker.  See http://www.internationalgenome.org/category/allele-frequency/ for additional information. 

```{r, linewidth = 80}
#Recalculate the alternate allele frequency
muts$fix$AF <- muts$fix$AC/muts$fix$AN

#View the first three rows of the fixed data in muts
head(muts$fix, n = 3)
```

Our `sim_RVstudy` function expects mutation data to be formatted as a data frame.  Additionally, mutation data supplied to `sim_RVstudy` must contain the following variables:

1. `colID`: a numeric variable which associates the rows in the `mutations` data frame to the columns in the `haplotypes` matrix. 
2. `chrom`: represents the chromosome in which the SNV resides.
3. `position`: represents the position of the SNV in base pairs.
4. `afreq`: (Optional) the derived allele frequency of the SNV.

From the previous discussion, we know that the fixed data returned by `vcf2tidy` contains the variables `chrom`, `position`, and `afreq`. To make the output from the `vcf2tidy` function compatible with the format expected for the `sim_RVstudy` function we make the following changes.

```{r}
# store the fixed item in muts data as dataframe 
mutations <- as.data.frame(muts$fix)
```

```{r}
# Create the variable colID to identify the column position of the mutation.
# NOTE: Since mutations are already in the correct order, we accomplish this task 
# using the seq function.  Since the mutations are stored in the columns of
# the haplotypes matrix we determine the length of our sequence as the number of 
# columns in haplotypes.
mutations$colID <- seq(1:dim(haplotypes)[2])

# View the first three rows of mutations
head(mutations, n = 3)
``` 

```{r}
# Rename columns for consistency with expected format. 
# "AF" should be renamed "afreq",
# "CHROM" should be renamed "chrom", 
# and "POS" should be renamed "position".
colnames(mutations)[c(1, 2, 8)] = c("chrom", "position", "afreq")

# View the first three rows of mutations
head(mutations, n = 3)
```

## Create an Object of Class `SNVdata`

The constructor function for objects of class `SNVdata` has three arguments:

1. `Haplotypes` A sparse matrix of haplotype data, which contains the haplotypes for unrelated individuals representing the founder population.
2. `Mutations` A data frame that catalogs the SNVs in the columns of the `Haplotypes` matrix. `Mutations` must include the following variables:

    * `colID`: a numeric variable which associates the rows in `Mutations` to the columns in `Haplotypes`. 
    * `chrom`: represents the chromosomal in which the SNV resides.
    * `position`: represents the chromosomal position of the SNV in base pairs.
    * `afreq`: (Optional) the derived allele frequency of the SNV.
3. `Samples` (Optional) this argument allows users to provide data for the individuals whose haplotypes are stored in `Haplotypes`.

The sample data, which describes the individuals whose genotypes are contained in the vcf data for chromosome 21 (i.e. from sections XX and XX), may be obtained as follows:

```{r, tidy = TRUE}
file_path <- 'https://raw.githubusercontent.com/simrvprojects/1000-Genomes-Exon-Data/master/Vignette%20Data/SampleInfo1.csv'
SampleInfo <- read.csv(file_path)
```

```{r}
#View the first 6 lines of the sample data
head(SampleInfo)
```

From the output above, we see that `SampleInfo` describes the individuals contained in the vcf file.  For each individual, the cataloged information includes population descriptions as well as information on any relations that are included in this data set.  We caution users against using haplotype data that includes related individuals as this may result in cryptic relatedness among pedigree founders. To avoid this, we must remove any relatives from the founder haplotype data.  The `SampleInfo` data set includes 42 individuals who have been listed as third order or higher relatives.  We reduced `SampleInfo` by randomly sampling one relative from each set of related individuals.  This resulted in the removal of 22 individuals.  Additionally, we removed any individuals from the `SampleInfo` whose genotypes were not contained in the vcf data.  This resulted in the removal of additional 930 individuals. Users interested in following the sample-reduction process may find our script at: https://github.com/simrvprojects/SimRVSequences/blob/master/data-raw/format_sample_data.R.

To import the reduced sample data, we execute the following commands:
```{r}
file_path <- 'https://raw.githubusercontent.com/simrvprojects/1000-Genomes-Exon-Data/master/Formatted-SNVdata/SampleData.csv'
SampleData <- read.csv(file_path)

# view the first 6 lines of SampleData
head(SampleData)
```

Next, we must reduce the haplotype data to include only the individuals who are contained in SampleData.  We achieve this as follows:

```{r}
# View dimensions of haplotypes
dim(haplotypes)
```
From the output above, we see that `haplotypes` contains 5096 haplotypes spanning 15,524 SNVs.  Since these are the haplotypes of diploid organisms this matrix contains data for 2048 individuals. 

```{r}
# Recall that the row names in the haplotypes matrix are the sample IDs
row.names(haplotypes)[1:5]

# Reduce the haplotype data to contain the 
# unrelated individuals described in SampleData 
haplotypes <- haplotypes[row.names(haplotypes) %in% SampleData$Sample, ]

# View the new dimensions of haplotypes
dim(haplotypes)
```

Comparing the new dimensions to the original dimensions, we see that 44 rows have been removed, which corresponds to the removal of 22 diploid individuals.

Finally, we are ready to create an object of class `SNVdata`.  To create this object we supply the required arguments to the `SNVdata` constructor function as follows.

```{r, linewidth = 80}
#create SNVdata object for chromosome 21 without sample or meta data
SNVdata_chrom21 <- SNVdata(Haplotypes = haplotypes, 
                           Mutations = mutations,
                           Samples = SampleData)
str(SNVdata_chrom21)
```


We note that `SNVdata` objects can be much smaller than the original `vcfR` objects for the same data set.  To determine the size of each of these objects we use the `object_size` function from the `pryr` package. 
```{r}
library(pryr)

# Determine size of vcfR object for chromosome 21
object_size(vcf_chrom21)

# Determine size of SNVdata object for chromosome 21
object_size(SNVdata_chrom21)
```

We note that while the size reduction between the `vcfR` and `SNVdata` object for this chromosome is quite drastic, the size of the `SNVdata` object is very similar to the size of the zipped vcf file for chromosome 21.  Even so, this format may be very useful for large, sparse, genomic data sets in R.

# Import 1000 Genomes Exon Data with `import_SNVdata`

The SNVdata objects for each chromosome are stored in the "Formatted-SNVdata" folder in the GitHub repository.

The `import_SNVdata` function allows users to import formatted SNV data for each chromosome.  The `import_SNVdata` function has two arguments:

  1. `chrom` A number or list of numbers that specify which non-sex chromosomes to import.
  2. `pathway_df` (Optional) A data frame that contains the positions for each exon in a pathway of interest.  This data frame must contain the variables `chrom`, `exonStart`, and `exonEnd`.  *We expect that `pathwayDF` does not contain any overlapping segments.  Users may combine overlapping exons into a single observation with our `combine_exons` function.  For additional information regarding the `combine_exons` function please  execute `help(combine_exons)` in the console.*

```{r, linewidth = 80}
# load the hg_apopPath dataset
data("hg_apopPath")

#import SNV data for chromosomes 21 and 22 and identify 
#SNVs located in the pathway defined by hg_apopPath 
EXdata = import_SNVdata(21:22, pathway_df = hg_apopPath)

# determine the structure of EXdata
str(EXdata)
```


Note that any SNVs in the pathway contained in the `hg_apopPath` data will be identified by the variable `pathwaySNV` in the `Mutations` data frame of `EXdata`.

```{r}
# View the first 6 SNVs contained in the pathway of interest
head(EXdata$Mutations[EXdata$Mutations$pathwaySNV, ])
```

# References
[1] Douglas Bates and Martin Maechler (2018). 
  **Matrix: Sparse and Dense Matrix Classes and Methods**. 
  *R package version 1.2-14*. https://CRAN.R-project.org/package=Matrix
  
[2] Knaus BJ, Grünwald NJ (2015). 
  **VCFR: a package to manipulate and visualize variant call format data in R.**
  Molecular Ecology Resources, 17(1): 44-53.
